#Chapter 1 算法简介

大O表示法指出了最糟情况下的运行时间

#Chapter 2 选择排序

2.1 链表 linked list

链表种的元素可存储在内存的任何地方，链表的每个元素都存储了下一个元素的地址。所以，链表不能跳跃访问元素，因此需要数组。

2.2 数组 array


链表更适合插入，只需修改前面元素指向的地址；数组则必须将后面的元素后移。
同理，链表也更适合删除。

但通常数组用的更多，因为支持随机访问。

#Chapter 3 递归

递归只是让解决方案更清晰，并没有性能上的优势。
如果使用循环，程序性能可能更高；使用递归，程序更容易理解

递归 = 基线条件+递归条件  base case + recursive case

**调用另一函数时，当前函数暂停并处于未完成状态。该函数的所有变量的值都还在内存中。**

如果栈很高，计算机需要存储大量函数调用的信息。解决方法：
1. 改用循环
2. 尾递归

#Chapter 4 快速排序

分而治之, divide and conquer, D&G

quicksort性能高度依赖于你选择的基准值

当两种算法有相同的大O时，需要考虑常量的影响。
quicksort
1. 每次选第一个元素作为pivot，栈高O(n),最糟糕。
2. 每次选中间元素作为pivot，栈高O(logn),最佳。
3. 每层栈长均为O(n)。
4. 故需要时间分别为O($n^2$)和O(nlogn)。
   
mergesort
虽然运行时间也时O(nlogn)，但常量大，故不如quicksort。

#Chapter 5 散列表 hash table

散列函数：将输入映射到数字
将网址映射到IP地址就是一种散列表，称为DNS解析
网页缓存的数据存储在散列表中。
重点
1. 散列函数将键均匀地映射到散列表的不同位置
2. 如果使用的散列函数很好，链表就不会很长

如何避免冲突：
1. 较低的填装因子； （散列表包含的元素数/位置总数）
2. 良好的散列函数。   

#Chapter 6 广度优先搜索
两类问题
1. 从节点A出发，有前往节点B的路径吗？
2. 从节点A出发，前往节点B的哪条路径最短？
   
队列（FIFO，first in first out）；栈（LIFO，last in first out）

#Chapter 7 狄克斯特拉算法

1. 找出最便宜的节点，即可在最短时间内前往的节点。
2. 对于该节点的邻居，检查是否有前往它们的更短的路径，如果有，就更新其开销。
3. 重复这个过程，直到对图中的每个节点都这样做。
4. 计算最终路径

加权图和非加权图； 狄克斯特拉算法只适用于有向无环图（directed acyclic graph，DAG）
负边权无法使用该算法，但可以使用贝尔曼-福德算法


#Chapter 9 动态规划(DP)

仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。
1. 每种动态规划解决方案都涉及网格。
2. 单元格中的值通常就是要优化的值。
3. 每个单元格都是一个子问题。

最长公共子串与最长公共子序列的区别；一个取0，一个取max
